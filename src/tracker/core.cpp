/*
Copyright (c) 2018, Tom Bannink
MIT License
*/

#include "core.h"
#include "util.h"
#include "analysis.h"
#include <string.h>
#include "interface/vcos/vcos.h" // For threads and semaphores


// Update the size of the (green) field bounding box every X frames
constexpr int FieldUpdateDelay = 10;


// Divisions by 2 of 720p with correct aspect ratio
// 1280,720
//  640,360
//  320,180
//  160, 90
//   80, 45

// Every step maintains the same aspect ratio
// -- Source is 720p
const int width0  = 1280;
const int height0 = 720;
// -- From source to phase 1: 2x2 sampler-average, then hue filter
// -- 2x2 pixels to 1 pixel
const int width1  = 640 / 4; // RGBA can store 4 values at once
const int height1 = 360;
// -- From phase 1 to phase 2: average
// -- 8x8 pixels to 1 pixel
const int width2  = 80 / 4;
const int height2 = 45;

Texture ball_tex1;
Texture ball_tex2;
Texture field_tex1;
Texture field_tex2;
#ifdef DO_DIFF
Texture rtt_copytex;
#endif


constexpr int PIXELBUFFER_COUNT = 4;
uint8_t* pixelbuffers[PIXELBUFFER_COUNT]; // For reading out result
uint8_t* fieldbuffer;

int nextEmptyBuffer = 0; // For writing buffers
int nextFullBuffer = 0;  // For reading buffers

void* analysis_thread(void *arg);
int analysis_stop = 0;
VCOS_THREAD_T analysis_thread_handle;
VCOS_SEMAPHORE_T semEmptyCount; // analysis -> GL signal
VCOS_SEMAPHORE_T semFullCount;  // GL -> analysis signal


GLfloat quad_varray[] = {
   -1.0f, -1.0f, 1.0f, -1.0f, 1.0f, 1.0f,
   -1.0f, 1.0f, -1.0f, -1.0f, 1.0f, 1.0f,
};

GLuint quad_vbo; // vertex buffer object
GLuint fbo;      // frame buffer object for render-to-texture


// Autogenerated file containing all shaders
#include "balltrackshaders/allshaders.h"

SHADER_PROGRAM_T shader_huefilter_ball =
{
    .vertex_source = (char*)vshader_vert,
    .fragment_source = (char*)huefilterball_frag,
    .uniforms = {ShaderUniform("tex", 0), ShaderUniform("tex_unit", 1.0f / (float)width0, 1.0f / (float)height0)},
    .attribute_names = {"vertex"},
};

SHADER_PROGRAM_T shader_huefilter_field =
{
    .vertex_source = (char*)vshader_vert,
    .fragment_source = (char*)huefilterfield_frag,
    .uniforms = {ShaderUniform("tex", 0), ShaderUniform("tex_unit", 1.0f / (float)width0, 1.0f / (float)height0)},
    .attribute_names = {"vertex"},
};

SHADER_PROGRAM_T shader_downsample =
{
    .vertex_source = (char*)vshader_vert,
    .fragment_source = (char*)downsample_frag,
    .uniforms = {ShaderUniform("tex", 0), ShaderUniform("tex_unit", 1.0f / (float)width1, 1.0f / (float)height1)},
    .attribute_names = {"vertex"},
};

SHADER_PROGRAM_T shader_simple =
{
    .vertex_source = (char*)vshader_vert,
    .fragment_source = (char*)simple_frag,
    .uniforms = {ShaderUniform("tex", 0)},
    .attribute_names = {"vertex"},
};

SHADER_PROGRAM_T shader_debug =
{
    .vertex_source = (char*)vshader_vert,
    .fragment_source = (char*)debug_frag,
    .uniforms = {
        ShaderUniform("tex_camera", 0),
        ShaderUniform("tex_dbg1", 1),
        ShaderUniform("tex_dbg2", 2),
        ShaderUniform("tex_dbg3", 3),
        ShaderUniform("pixelwidth1", 1.0f / (float)width1),
        ShaderUniform("pixelwidth2", 1.0f / (float)width2),
        ShaderUniform("pixelwidth3", 1.0f / (float)width2),
    },
    .attribute_names = {"vertex"},
};

SHADER_PROGRAM_T shader_fixedcolor =
{
    .vertex_source = (char*)vshader_vert,
    .fragment_source = (char*)fixedcolor_frag,
    .uniforms = { ShaderUniform("col") },
    .attribute_names = {"vertex"},
};

SHADER_PROGRAM_T shader_yuv =
{
    .vertex_source = (char*)vshader_vert,
    .fragment_source = (char*)yuvsource_frag,
    .uniforms = { ShaderUniform("tex_rgb", 0),
        ShaderUniform("tex_y", 2),
        ShaderUniform("tex_u", 3),
        ShaderUniform("tex_v", 4)
    },
    .attribute_names = {"vertex"},
};

#ifdef DO_DIFF
SHADER_PROGRAM_T shader_diff =
{
    .vertex_source = (char*)vshader_vert,
    .fragment_source = (char*)diff_frag,
    .uniforms = { ShaderUniform("tex1", 0), ShaderUniform("tex2", 1) },
    .attribute_names = {"vertex"},
};
#endif

void replace_sampler_string(const char* text) {
    // In text, find and replace:
    // "samplerExternalOES"
    // "sampler2D         "
    char* pos = 0;
    if ((pos = strstr((char*)text, "samplerExternalOES"))){
        memcpy(pos, "sampler2D         ", 18);
    }
}

int balltrack_core_init(int externalSamplerExtension, int flipY)
{
    int rc = 0;

    const char* glRenderer = (const char*)glGetString(GL_RENDERER);
    printf("OpenGL renderer string: %s\n", glRenderer);

    // When the source data comes from the camera, the shaders have
    //     samplerExternalOES
    // and when the data comes from a video file, the shaders need
    //     sampler2D
    // So this code replaces those when needed.
    if (externalSamplerExtension == 0) {
        replace_sampler_string(shader_huefilter_ball.fragment_source);
        replace_sampler_string(shader_huefilter_field.fragment_source);
        replace_sampler_string(shader_debug.fragment_source);
        replace_sampler_string(shader_simple.fragment_source);
        replace_sampler_string(shader_yuv.fragment_source);
#ifdef DO_DIFF
        replace_sampler_string(shader_diff.fragment_source);
#endif
    }

    // Camera source is Y-flipped.
    // So flip it back in the vertex shader
    if (flipY) {
        // TODO:
        // Do not flip the render-to-texture textures ??
        //balltrack_shader_1.vertex_source = BALLTRACK_VSHADER_YFLIP_SOURCE;
        //balltrack_shader_2.vertex_source = BALLTRACK_VSHADER_YFLIP_SOURCE;
        //balltrack_shader_3.vertex_source = BALLTRACK_VSHADER_YFLIP_SOURCE;
    }

    printf("Building shader `huefilter ball`\n");
    rc = balltrack_build_shader_program(&shader_huefilter_ball);
    if (rc != 0)
        return rc;

    printf("Building shader `huefilter field`\n");
    rc = balltrack_build_shader_program(&shader_huefilter_field);
    if (rc != 0)
        return rc;

    printf("Building shader `downsample`\n");
    rc = balltrack_build_shader_program(&shader_downsample);
    if (rc != 0)
        return rc;

#ifdef DEBUG_TEXTURES
    printf("Building shader `debug`\n");
    rc = balltrack_build_shader_program(&shader_debug);
    if (rc != 0)
        return rc;
#endif

    printf("Building shader `simple`\n");
    rc = balltrack_build_shader_program(&shader_simple);
    if (rc != 0)
        return rc;

    printf("Building shader `fixedcolor`\n");
    rc = balltrack_build_shader_program(&shader_fixedcolor);
    if (rc != 0)
        return rc;

    printf("Building shader `yuv`\n");
    rc = balltrack_build_shader_program(&shader_yuv);
    if (rc != 0)
        return rc;

#ifdef DO_DIFF
    printf("Building shader `diff`\n");
    rc = balltrack_build_shader_program(&shader_diff);
    if (rc != 0)
        return rc;
#endif

    // Buffer to read out pixels from last texture
    uint32_t buffer_size = width2 * height2 * 4;
    for (int i = 0; i < PIXELBUFFER_COUNT; ++i) {
        pixelbuffers[i] = (uint8_t*)malloc(buffer_size);
        if (!pixelbuffers[i]) {
            printf("Could not allocate balltracking ball pixelbuffer.\n");
            return -1;
        }
    }
    fieldbuffer = (uint8_t*)malloc(buffer_size);
    if (!fieldbuffer) {
        printf("Could not allocate balltracking field pixelbuffer.\n");
        return -1;
    }

    printf("Generating framebuffer object\n");
    // Create frame buffer object for render-to-texture
    GLCHK(glGenFramebuffersOES(1, &fbo));
    GLCHK(glBindFramebufferOES(GL_FRAMEBUFFER_OES, fbo));
    GLCHK(glBindFramebufferOES(GL_FRAMEBUFFER_OES, 0)); // unbind it

    printf("Creating render-to-texture targets\n");
    ball_tex1 = createFilterTexture(width1, height1, GL_LINEAR);
    ball_tex2 = createFilterTexture(width2, height2, GL_LINEAR);
    field_tex1 = createFilterTexture(width1, height1, GL_LINEAR);
    field_tex2 = createFilterTexture(width2, height2, GL_LINEAR);

#ifdef DO_DIFF
    rtt_copytex = createFilterTexture(width0, height0, GL_NEAREST);
#endif

    printf("Creating vertex-buffer object\n");
    GLCHK(glGenBuffers(1, &quad_vbo));
    GLCHK(glBindBuffer(GL_ARRAY_BUFFER, quad_vbo));
    GLCHK(glBufferData(GL_ARRAY_BUFFER, sizeof(quad_varray), quad_varray, GL_STATIC_DRAW));
    GLCHK(glClearColor(0.0f, 0.0f, 0.0f, 0.0f));

    GLCHK(glDisable(GL_BLEND));
    GLCHK(glDisable(GL_DEPTH_TEST));

    // Create a binary and N-ary semaphore and start an analysis thread
    // Also allocate N pixelbuffers
    // For every glReadPixels, use semaphores to get a free buffer
    // and read into there.
    // Then the analysis thread can consume the buffers from there,
    // while the GL thread continues.
    VCOS_STATUS_T status;

    status = vcos_semaphore_create(&semFullCount, "analysis_fullcount", 0);
    if (status != VCOS_SUCCESS) {
        printf("Failed to create balltrack semaphore %d\n", status);
        return -1;
    }

    status = vcos_semaphore_create(&semEmptyCount, "analysis_emptycount", PIXELBUFFER_COUNT);
    if (status != VCOS_SUCCESS) {
        printf("Failed to create balltrack semaphore %d\n", status);
        return -1;
    }

    status = vcos_thread_create(&analysis_thread_handle, "analysis-thread", NULL, analysis_thread, 0);
    if (status != VCOS_SUCCESS) {
        printf("Failed to start balltrack analysis thread %d\n", status);
        return -1;
    }

    return 0;
}

void balltrack_core_term()
{
    // Wait for analysis thread to finish
    analysis_stop = 1;
    vcos_thread_join(&analysis_thread_handle, NULL);
    vcos_semaphore_delete(&semFullCount);
    vcos_semaphore_delete(&semEmptyCount);

    // TODO: Cleanup textures, shaders, everything
    return;
}


void balltrack_process_ball_buffer(uint8_t* pixelbuffer);
void balltrack_process_field_buffer(uint8_t* pixelbuffer);

void* analysis_thread(void *arg)
{
    printf("Balltrack analysis thread started.\n");
    while (analysis_stop == 0) {
        // Wait for GL thread till there is a full buffer
        vcos_semaphore_wait(&semFullCount);

        // Get the buffer
        uint8_t* buffer = pixelbuffers[nextFullBuffer];
        ++nextFullBuffer;
        if (nextFullBuffer == PIXELBUFFER_COUNT)
            nextFullBuffer = 0;

        // Process the buffer
        balltrack_process_ball_buffer(buffer);

        // Notify GL thread that a buffer is available
        vcos_semaphore_post(&semEmptyCount);
    }
    printf("Balltrack analysis thread ending.\n");
    return 0;
}

void balltrack_readout() {
    int width = width2;
    int height = height2;
    uint8_t* buf = 0;

    // Wait for analysis thread for an empty buffer
    vcos_semaphore_wait(&semEmptyCount);

    // Claim it
    buf = pixelbuffers[nextEmptyBuffer];
    ++nextEmptyBuffer;
    if (nextEmptyBuffer == PIXELBUFFER_COUNT)
        nextEmptyBuffer = 0;

    GLCHK(glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, buf));

    // Notify analysis thread
    vcos_semaphore_post(&semFullCount);
}


// x,y are coordinates in [-1,1]x[-1,1] range
void draw_line_strip(POINT* xys, int count, uint32_t color) {
    if (count == 0)
        return;

    float r, g, b, a;
    r = (1.0/255.0) * ((color      ) & 0xff);
    g = (1.0/255.0) * ((color >>  8) & 0xff);
    b = (1.0/255.0) * ((color >> 16) & 0xff);
    a = (1.0/255.0) * ((color >> 24) & 0xff);

    SHADER_PROGRAM_T* shader = &shader_fixedcolor;
    GLCHK(glUseProgram(shader->program));
    GLCHK(glUniform4f(shader->uniforms[0].location, r, g, b, a));

    // Unbind the vertex buffer --> use client memory
    GLCHK(glBindBuffer(GL_ARRAY_BUFFER, 0));
    GLCHK(glEnableVertexAttribArray(shader->attribute_locations[0]));
    GLCHK(glVertexAttribPointer(shader->attribute_locations[0], 2, GL_FLOAT, GL_FALSE, 0, (GLfloat*)xys));
    // Draw
    GLCHK(glDrawArrays(GL_LINE_STRIP, 0, count));
}

// x,y are coordinates in [-1,1]x[-1,1] range
void draw_square(float xmin, float xmax, float ymin, float ymax, uint32_t color) {
    // Draw a square
    POINT vertexBuffer[5];
    vertexBuffer[0].x = xmin;
    vertexBuffer[0].y = ymin;
    vertexBuffer[1].x = xmax;
    vertexBuffer[1].y = ymin;
    vertexBuffer[2].x = xmax;
    vertexBuffer[2].y = ymax;
    vertexBuffer[3].x = xmin;
    vertexBuffer[3].y = ymax;
    vertexBuffer[4].x = xmin;
    vertexBuffer[4].y = ymin;
    draw_line_strip(vertexBuffer, 5, color);
}

// If target.id is zero, then target is the screen
int render_pass(SHADER_PROGRAM_T* shader, Texture source, Texture target) {
    GLCHK(glUseProgram(shader->program));
    if (target.id) {
        // Enable Render-to-texture and set the output texture
        GLCHK(glBindFramebufferOES(GL_FRAMEBUFFER_OES, fbo));
        GLCHK(glFramebufferTexture2DOES(GL_FRAMEBUFFER_OES, GL_COLOR_ATTACHMENT0_OES, GL_TEXTURE_2D, target.id, 0));
        GLCHK(glViewport(0, 0, target.width, target.height));
        // According to the open source GL driver for the VC4 chip,
        // [ https://github.com/anholt/mesa/wiki/VC4-Performance-Tricks ],
        // it is faster to clear the buffer even when writing to the complete screen
        glClear(GL_COLOR_BUFFER_BIT);
    } else {
        // Unset frame buffer object. Now draw to screen
        GLCHK(glBindFramebufferOES(GL_FRAMEBUFFER_OES, 0));
        GLCHK(glViewport(0, 0, target.width, target.height));
        glClear(GL_COLOR_BUFFER_BIT); // See above comment
    }
    // Bind the input texture
    GLCHK(glActiveTexture(GL_TEXTURE0));
    GLCHK(glBindTexture(source.type, source.id));
    // Bind the vertex buffer
    GLCHK(glBindBuffer(GL_ARRAY_BUFFER, quad_vbo));
    GLCHK(glEnableVertexAttribArray(shader->attribute_locations[0]));
    GLCHK(glVertexAttribPointer(shader->attribute_locations[0], 2, GL_FLOAT, GL_FALSE, 0, 0));
    // Draw
    GLCHK(glDrawArrays(GL_TRIANGLES, 0, 6));
    return 0;
}

int frameNumber = 0;
int fieldUpdateSteps = 0;

FIELD field;

int balltrack_core_process_image(int width, int height, GLuint srctex, GLuint srctype)
{
    ++frameNumber;
    // Width,height is the size of the preview window on screen
    Texture screen;
    screen.id = 0;
    screen.width = width;
    screen.height = height;

    Texture input;
    input.id = srctex;
    input.width = 0;
    input.height = 0;
    input.type = srctype;

#ifdef DO_FRAMEDUMP
    if (frameNumber == 60) {
        render_pass(&shader_simple, input, screen);
        dump_frame(width, height, "framedump.tga");
        printf("Frame dumped to framedump.tga\n");
    }
#endif

#ifdef DO_DIFF
    // Diff with previous
    GLCHK(glActiveTexture(GL_TEXTURE1));
    GLCHK(glBindTexture(GL_TEXTURE_2D, rtt_copytex));
    render_pass(&shader_diff, input, screen);

    // Copy source to previous
    render_pass(&shader_simple, input, rtt_copytex);
#endif

    if (fieldUpdateSteps == 0) {
        // Update the size of the green field bounding box
        render_pass(&shader_huefilter_field, input, field_tex1);
        render_pass(&shader_downsample, field_tex1, field_tex2);

        // We could do this in a separate thread,
        // but since its not every frame, we dont bother
        GLCHK(glReadPixels(0, 0, width2, height2, GL_RGBA, GL_UNSIGNED_BYTE, fieldbuffer));
        balltrack_process_field_buffer(fieldbuffer);

        fieldUpdateSteps = FieldUpdateDelay;
    }
    --fieldUpdateSteps;

    // First pass: hue filter into smaller texture
    render_pass(&shader_huefilter_ball, input, ball_tex1);
    // Second pass: 8X smaller in both directions
    render_pass(&shader_downsample, ball_tex1, ball_tex2);
    // Readout result
    balltrack_readout();
    
    // Last pass: render to screen
#ifdef DEBUG_TEXTURES
    GLCHK(glActiveTexture(GL_TEXTURE1));
    GLCHK(glBindTexture(GL_TEXTURE_2D, ball_tex1.id));
    GLCHK(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST));

    GLCHK(glActiveTexture(GL_TEXTURE2));
    GLCHK(glBindTexture(GL_TEXTURE_2D, ball_tex2.id));
    GLCHK(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST));

    GLCHK(glActiveTexture(GL_TEXTURE3));
    GLCHK(glBindTexture(GL_TEXTURE_2D, field_tex2.id));
    GLCHK(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST));

    render_pass(&shader_debug, input, screen);

    // Set scaling back to linear
    GLCHK(glActiveTexture(GL_TEXTURE1));
    GLCHK(glBindTexture(GL_TEXTURE_2D, ball_tex1.id));
    GLCHK(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
    GLCHK(glActiveTexture(GL_TEXTURE2));
    GLCHK(glBindTexture(GL_TEXTURE_2D, ball_tex2.id));
    GLCHK(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
    GLCHK(glActiveTexture(GL_TEXTURE3));
    GLCHK(glBindTexture(GL_TEXTURE_2D, field_tex2.id));
    GLCHK(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
#else
    render_pass(&shader_simple, input, screen);
#endif

    // Draw field and ball positions on top
    // TODO: This is currently quite slow
    analysis_draw(field);

    return 0;
}

// This runs in a separate thread
void balltrack_process_ball_buffer(uint8_t* pixelbuffer) {
    // It packs four pixels into one RGBA pixel
    // Since ARM is little-endian, this becomes very simple
    // and we can simply threat it as an uint8 buffer of four times the width
    int width = 4 * width2;
    int height = height2;

    int fieldxmin = (int)(0.5f * (1.0f + field.xmin) * (float)width - 1.0f);
    int fieldxmax = (int)(0.5f * (1.0f + field.xmax) * (float)width + 1.0f);
    int fieldymin = (int)(0.5f * (1.0f + field.ymin) * (float)height - 1.0f);
    int fieldymax = (int)(0.5f * (1.0f + field.ymax) * (float)height + 1.0f);

    // TODO: BLUR ?

    // Find the max orange intensity
    int maxx = 0, maxy = 0;
    uint32_t maxValue = 0;
    uint8_t* ptr = pixelbuffer;
    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            uint32_t value = (uint32_t) *ptr++;

            if ( y < fieldymin || y > fieldymax ) continue;
            if ( x < fieldxmin || x > fieldxmax ) continue;
            if (value > maxValue) {
                maxx = x;
                maxy = y;
                maxValue = value;
            }
        }
    }

    // Take weighted average near the maximum
    int avgx = 0, avgy = 0;
    int weight = 0;
    ptr = pixelbuffer;
    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            uint32_t value = (uint32_t) *ptr++;
            if (y < maxy - 5 || y > maxy + 5) continue;
            if (x < maxx - 5 || x > maxx + 5) continue;
            avgx += x * value;
            avgy += y * value;
            weight += value;
        }
    }

    // avgx, avgy are the bottom-left corner of the macropixels
    // Shift them by half a pixel to fix
    float x = 0.5f + (((float)avgx) / ((float)weight));
    float y = 0.5f + (((float)avgy) / ((float)weight));

    int threshold1 = 30;
    int threshold2 = 60;

    // Map to [-1,1] range
    POINT ball;
    ball.x = (2.0f * x) / ((float)width) - 1.0f;
    ball.y = (2.0f * y) / ((float)height) - 1.0f;
    // Map to field coordinates
    ball.x = -1.0f + 2.0f * (ball.x - field.xmin) / (field.xmax - field.xmin);
    ball.y = -1.0f + 2.0f * (ball.y - field.ymin) / (field.ymax - field.ymin);

    bool ballFound = maxValue > threshold1 && weight > threshold2;
    analysis_update(frameNumber, field, ball, ballFound);
}

// This runs in a separate thread
void balltrack_process_field_buffer(uint8_t* pixelbuffer) {
    // It packs four pixels into one RGBA pixel
    // Since ARM is little-endian, this becomes very simple
    // and we can simply threat it as an uint8 buffer of four times the width
    int width = 4 * width2;
    int height = height2;

    // Start with a small bounding box in the middle and stretch it out
    int fieldxmin = (int)(0.48f * width);
    int fieldxmax = (int)(0.52f * width);
    int fieldymin = (int)(0.48f * height);
    int fieldymax = (int)(0.52f * height);

    uint8_t* ptr = pixelbuffer;
    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            uint32_t value = (uint32_t) *ptr++;

            if (value > 150) {
                if (x < fieldxmin) fieldxmin = x;
                if (x > fieldxmax) fieldxmax = x;
                if (y < fieldymin) fieldymin = y;
                if (y > fieldymax) fieldymax = y;
            }
        }
    }

    fieldxmin -= 4;
    fieldxmax += 4;
    fieldymin -= 3;
    fieldymax += 3;
    if (fieldxmin < 0) fieldxmin = 0;
    if (fieldymin < 0) fieldymin = 0;
    if (fieldxmax >= width) fieldxmax = width - 1;
    if (fieldymax >= height) fieldymax = height - 1;

    // Map to [-1,1]
    FIELD newField;
    newField.xmin = (2.0f * fieldxmin) / ((float)width) - 1.0f;
    newField.xmax = (2.0f * fieldxmax) / ((float)width) - 1.0f;
    newField.ymin = (2.0f * fieldymin) / ((float)height) - 1.0f;
    newField.ymax = (2.0f * fieldymax) / ((float)height) - 1.0f;

    // Time average for field, because it fluctuates too much
    field.xmin = 0.92f * field.xmin + 0.08 * newField.xmin;
    field.xmax = 0.92f * field.xmax + 0.08 * newField.xmax;
    field.ymin = 0.92f * field.ymin + 0.08 * newField.ymin;
    field.ymax = 0.92f * field.ymax + 0.08 * newField.ymax;
}

